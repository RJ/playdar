<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE library PUBLIC "-//Boost//DTD BoostBook XML V1.0//EN" "http://www.boost.org/tools/boostbook/dtd/boostbook.dtd">
<section id="process.design">
  <title>Design overview</title>
  <para>Boost.Process is a rather small library to make it as simple as possible for developers to create, control and communicate with processes. For a better idea how the library's structure looks like the following diagram has been created.</para>
  <mediaobject>
    <imageobject>
      <imagedata fileref="design.png"/>
    </imageobject>
  </mediaobject>
  <para>The most important classes are <classname alt="boost::process::context">context</classname> and <classname alt="boost::process::child">child</classname>: They implement the <link linkend="process.concepts.context">Context</link> and <link linkend="process.concepts.process">Process</link> concepts Boost.Process is built on. While <link linkend="process.concepts.context">Context</link> is used to setup the overall context the new process will run in, <link linkend="process.concepts.process">Process</link> describes any process. Currently it's only possible to access children via <classname alt="boost::process::child">child</classname> and the current process via <classname alt="boost::process::self">self</classname>. As of today there is no way to access other processes.</para>
  <para>In order to communicate with a child <classname alt="boost::process::pistream">pistream</classname> and <classname alt="boost::process::postream">postream</classname> are used. They can be accessed via <classname alt="boost::process::child">child</classname> and represent input and output streams. By default all streams are closed when a child is started. The context has to be configured appropriately to redirect streams if a parent should be able to communicate with a child.</para>
  <para>A process can wait for a child to terminate. When it is terminated <classname alt="boost::process::status">status</classname> enables the process to fetch the exit code of the child.</para>
  <para>If more than one child should be created and the children should be connected with each other <classname alt="boost::process::pipeline_entry">pipeline_entry</classname> is used to specify the context of every child in the pipeline. As a pipeline consists of more than one process <classname alt="boost::process::children">children</classname> is used to manage the entire pipeline. It's then for example not possible to communicate via <classname alt="boost::process::pistream">pistream</classname> and <classname alt="boost::process::postream">postream</classname> with each and every child in the pipeline but only with the first and last child (as the children in the pipeline communicate with each other).</para>
  <para>As Boost.Process is platform-independent by default only those features are supported which are available on all platforms. As POSIX and Windows platforms support more features additional classes are provided in case platform-specific features should be used.</para>
  <section id="process.design.steps">
    <title>Creating, controlling and communicating with a child</title>
    <para>There are basically four steps when a child is spawned:</para>
    <itemizedlist>
      <listitem>
        <para>Before a process can be created <classname alt="boost::process::context">context</classname> (in <filename class="headerfile">boost/process/context.hpp</filename>) must be setup. This includes specifying what should happen with the input, output and error streams (eg. if they should be closed or redirected) and how the environment table which contains environment variables should look like. The classes <classname alt="boost::process::posix_context">posix_context</classname> (in <filename class="headerfile">boost/process/posix_context.hpp</filename>) and <classname alt="boost::process::win32_context">win32_context</classname> (in <filename class="headerfile">boost/process/win32_context.hpp</filename>) support additional options which are only available on the respective platforms (eg. setting the <ulink url="http://www.opengroup.org/onlinepubs/000095399/functions/setuid.html">uid</ulink> on POSIX platforms or passing a <ulink url="http://msdn.microsoft.com/en-us/library/ms686331(VS.85).aspx">STARTUPINFO</ulink> object on Windows platforms).</para>
      </listitem>
      <listitem>
        <para>After a context has been created it is passed to a function which starts the process and returns <classname alt="boost::process::child">child</classname>. The header file <filename class="headerfile">boost/process/operations.hpp</filename> provides the template function <function alt="boost::process::launch">launch</function> which requires the caller to pass the name of the executable (typically <classname>std::string</classname>), a set of arguments (typically <classname>std::vector&lt;std::string&gt;</classname> and the <classname alt="boost::process::context">context</classname> object. The template functions <function alt="boost::process::win32_launch">win32_launch</function> (in <filename class="headerfile">boost/process/win32_operations.hpp</filename>) and <function alt="boost::process::posix_launch">posix_launch</function> (in <filename class="headerfile">boost/process/posix_operations.hpp</filename>) must be called if the classes <classname alt="boost::process::posix_context">posix_context</classname> and <classname alt="boost::process::win32_context">win32_context</classname> have been used to setup a context. While <function alt="boost::process::launch">launch</function> returns a <classname alt="boost::process::child">child</classname> object, <function alt="boost::process::posix_launch">posix_launch</function> returns a <classname alt="boost::process::posix_child">posix_child</classname> object (in <filename class="headerfile">boost/process/posix_child.hpp</filename>) and <function alt="boost::process::win32_launch">win32_launch</function> a <classname alt="boost::process::win32_child">win32_child</classname> object (in <filename class="headerfile">boost/process/win32_child.hpp</filename>).</para>
      </listitem>
      <listitem>
        <para>If the context has been setup to redirect streams it is possible to access the child's input, output and error streams. The library provides two classes <classname alt="boost::process::pistream">pistream</classname> (in <filename class="headerfile">boost/process/pistream.hpp</filename>) and <classname alt="boost::process::postream">postream</classname> (in <filename class="headerfile">boost/process/postream.hpp</filename>) which are derived from <classname>std::istream</classname> respectively <classname>std::ostream</classname> and thus behave like standard C++ streams. They can be used to write to the child's input stream and to read from the child's output and error streams (always assuming that the context has been setup in a way that these streams are redirected). Of course it's not required to communicate with a child at all - this step is optional.</para>
      </listitem>
      <listitem>
        <para>After having created a context, started a process and possibly communicated with the child it's possible to wait for the child to terminate, terminate the child explicitly or just forget about the child. If a process waits for the child to terminate and the child terminates a <classname alt="boost::process::status">status</classname> object (in <filename class="headerfile">boost/process/status.hpp</filename>) is returned which enables a process to check the exit code of the child (eg. if it returned EXIT_SUCCESS or EXIT_FAILURE). On POSIX platforms <classname alt="boost::process::posix_child">posix_child</classname> returns a <classname alt="boost::process::posix_status">posix_status</classname> object (in <filename class="headerfile">boost/process/posix_status.hpp</filename>) to check for example if the child dumped core.</para>
      </listitem>
    </itemizedlist>
  </section>
  <section id="process.design.io">
    <title>Support for blocking and asynchronous I/O</title>
    <para>When <classname alt="boost::process::pistream">pistream</classname> and <classname alt="boost::process::postream">postream</classname> objects are used to communicate with a child all read/write operations are blocking just like with any other standard C++ stream. If for example a process reads from a child and the child doesn't write data the read operation blocks until new data is written by the child.</para>
    <para>While there is no support for asynchronous I/O in <classname alt="boost::process::pistream">pistream</classname> and <classname alt="boost::process::postream">postream</classname> the underlying handle can be fetched and passed to <classname>boost::asio::posix::stream_descriptor</classname> respectively <classname>boost::asio::windows::stream_handle</classname> which are provided by <libraryname alt="Asio">Boost.Asio</libraryname>. On Windows platforms it is required to define BOOST_PROCESS_WINDOWS_USE_NAMED_PIPE as on Windows anonymous pipes which are used by default to redirect streams between processes don't support asynchronous I/O.</para>
    <para>For details check the <link linkend="process.tutorials">tutorials</link> for an example how to use asynchronous I/O with Boost.Asio.</para>
  </section>
</section>
